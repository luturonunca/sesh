#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR=$(CDPATH= cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)

die() {
  echo "sesh: $*" >&2
  exit 1
}

usage() {
  cat <<'EOF'
Usage:
  sesh z <output_dir>
  sesh time <output_dir>
  sesh eventstats <outputs_root> [--from N]
  sesh simstatus [--path DIR]
  sesh z all
  sesh time all
EOF
}

find_info_file() {
  local dir="$1"
  local -a files
  shopt -s nullglob
  files=("$dir"/info_*.txt)
  shopt -u nullglob
  (( ${#files[@]} )) || die "no info_*.txt found in $dir"
  printf '%s\n' "${files[0]}"
}

get_param() {
  local key="$1"
  local file="$2"
  awk -v k="$key" '
    BEGIN { FS="=" }
    $0 ~ "^[[:space:]]*"k"[[:space:]]*=" {
      val=$2
      gsub(/[[:space:]]/, "", val)
      print val
      exit
    }
  ' "$file"
}

require_param() {
  local key="$1"
  local file="$2"
  local val
  val=$(get_param "$key" "$file")
  [[ -n "$val" ]] || die "missing $key in $file"
  printf '%s\n' "$val"
}

cmd_z() {
  local outdir="$1"
  [[ -d "$outdir" ]] || die "not a directory: $outdir"
  local info
  info=$(find_info_file "$outdir")
  awk '
    /aexp/ { a=$3 }
    END {
      if (a<=0) exit 1
      printf "%.8f\n", (1.0/a)-1.0
    }
  ' "$info" || die "invalid aexp in $info"
}

cmd_z_all() {
  local -a outputs
  shopt -s nullglob
  outputs=(./output_*)
  shopt -u nullglob
  (( ${#outputs[@]} )) || die "no output_* directories found in ."
  local outdir outname
  for outdir in "${outputs[@]}"; do
    [[ -d "$outdir" ]] || continue
    outname=$(basename -- "$outdir")
    local z
    z=$(cmd_z "$outdir") || die "failed z for $outdir"
    printf "%s z=%s\n" "$outname" "$z"
  done
}

cmd_time() {
  local outdir="$1"
  [[ -d "$outdir" ]] || die "not a directory: $outdir"
  local info
  info=$(find_info_file "$outdir")
  awk '
    function asinh(x) { return log(x + sqrt((x * x) + 1.0)) }
    /aexp/ { a=$3 }
    /H0/ { H0=$3 }
    /omega_m/ { Om=$3 }
    /omega_l/ { Ol=$3 }
    END {
      if (a<=0 || H0<=0 || Om<=0 || Ol<=0) exit 1
      z=1/a-1
      H0s=H0*1000/(3.085677581e22)
      tH=1/H0s/3.15576e16
      t=(2/(3*sqrt(Ol)))*asinh(sqrt(Ol/Om)*a^(3/2))*tH
      t0=(2/(3*sqrt(Ol)))*asinh(sqrt(Ol/Om))*tH
      printf "z=%.3f  t=%.3f Gyr  lookback=%.3f Gyr\n", z, t, t0-t
    }
  ' "$info" || die "cosmology calculation failed for $info"
}

cmd_time_all() {
  local -a outputs
  shopt -s nullglob
  outputs=(./output_*)
  shopt -u nullglob
  (( ${#outputs[@]} )) || die "no output_* directories found in ."
  local outdir outname
  for outdir in "${outputs[@]}"; do
    [[ -d "$outdir" ]] || continue
    outname=$(basename -- "$outdir")
    local line
    line=$(cmd_time "$outdir") || die "failed time for $outdir"
    printf "%s %s\n" "$outname" "$line"
  done
}

cmd_eventstats() {
  local root="$1"
  local start="${2:-}"
  [[ -d "$root" ]] || die "not a directory: $root"
  if [[ -n "$start" ]]; then
    [[ "$start" =~ ^[0-9]+$ ]] || die "start must be an integer: $start"
  fi
  local -a outputs
  shopt -s nullglob
  outputs=("$root"/output_*)
  shopt -u nullglob
  (( ${#outputs[@]} )) || die "no output_* directories found in $root"

  local outdir outname
  local -a files
  for outdir in "${outputs[@]}"; do
    [[ -d "$outdir" ]] || continue
    outname=$(basename -- "$outdir")
    if [[ -n "$start" ]]; then
      local num="${outname#output_}"
      if (( 10#$num < 10#$start )); then
        continue
      fi
    fi
    shopt -s nullglob
    files=("$outdir"/stars_*.out*)
    shopt -u nullglob
    (( ${#files[@]} )) || die "no stars_*.out* found in $outdir"
    local z
    z=$(cmd_z "$outdir") || die "failed z for $outdir"
    awk -v out="$outname" -v z="$z" '
      $1==0 {c0++}
      $1==1 {c1++}
      $1==2 {c2++}
      $1==3 {c3++}
      function colorize(label, n) {
        if (n>0) return sprintf("\033[36m%s:%d\033[0m", label, n)
        return sprintf("%s:%d", label, n)
      }
      function fmtz(val, absval, dec) {
        absval = (val < 0) ? -val : val
        if (absval <= 0) return "0"
        dec = 2 - int(log(absval) / log(10))
        if (dec < 0) dec = 0
        return sprintf("%.*f", dec, val)
      }
      END {
        printf "%s %s %s %s %s        z=%s\n", out, colorize("SF", c0+0), colorize("SN", c1+0), colorize("B-SF", c2+0), colorize("B-SN2", c3+0), fmtz(z+0)
      }
    ' "${files[@]}"
  done
}

cmd_simstatus() {
  local root="${1:-.}"
  [[ -d "$root" ]] || die "not a directory: $root"

  local RED="" YELLOW="" BLUE="" CYAN="" GREEN="" BOLD="" RESET=""
  if [[ -t 1 && -z "${NO_COLOR:-}" ]]; then
    RED=$'\e[31m'
    YELLOW=$'\e[33m'
    BLUE=$'\e[34m'
    CYAN=$'\e[36m'
    GREEN=$'\e[32m'
    BOLD=$'\e[1m'
    RESET=$'\e[0m'
  fi

  local HOUR=$((60*60))
  local DAY=$((24*HOUR))
  local WEEK=$((7*DAY))
  local MONTH=$((30*DAY))

  printf "%-13s %-63s %-12s %s\n" "snapshot" "simulation" "z_latest" "last_write"
  printf "%-13s %-63s %-12s %s\n" "-----------" "---------------------------------------------------------------" "----------" "----------------"

  local simdir simname
  local -a snaps
  for simdir in "$root"/*/; do
    [[ -d "$simdir" ]] || continue
    simname=$(basename -- "$simdir")

    shopt -s nullglob
    snaps=("$simdir"/output_?????)
    shopt -u nullglob
    (( ${#snaps[@]} )) || continue
    local latest
    latest=$(printf '%s\n' "${snaps[@]}" | sort -V | tail -n 1)

    local infofile
    infofile=$(ls -1t "$latest"/info_* 2>/dev/null | head -n 1)
    [[ -n "$infofile" ]] || continue

    local zfmt
    zfmt=$(awk '
      /aexp/ { a=$3 }
      END {
        if (a<=0) exit 1
        printf "%.3f", (1.0/a)-1.0
      }
    ' "$infofile") || continue

    local mtime_epoch now_epoch age stamp
    mtime_epoch=$(stat -c %Y "$infofile")
    now_epoch=$(date +%s)
    age=$(( now_epoch - mtime_epoch ))
    stamp=$(date -d @"$mtime_epoch" '+%Y-%m-%d %H:%M')

    local color tag
    if (( age > MONTH )); then color=$RED; tag=">1mo"
    elif (( age > WEEK )); then color=$YELLOW; tag=">1w"
    elif (( age > DAY )); then color=$BLUE; tag=">1d"
    elif (( age > HOUR )); then color=$CYAN; tag=">1h"
    else color=$GREEN; tag="~1h"
    fi

    printf "%-13s %-63s %-12s %s\n" "$(basename -- "$latest")" "$simname" "$zfmt" "${color}${stamp} (${tag})${RESET}"
  done
}

main() {
  if (( $# < 1 )); then
    usage >&2
    exit 1
  fi

  local cmd="$1"
  local outdir="${2:-}"
  case "$cmd" in
    z)
      if [[ "$outdir" == "all" ]]; then cmd_z_all; else cmd_z "$outdir"; fi
      ;;
    time)
      if [[ "$outdir" == "all" ]]; then cmd_time_all; else cmd_time "$outdir"; fi
      ;;
    eventstats)
      local start=""
      if (( $# == 4 )) && [[ "$3" == "--from" ]]; then
        start="$4"
      elif (( $# > 2 )); then
        die "usage: sesh eventstats <outputs_root> [--from N]"
      fi
      cmd_eventstats "$outdir" "$start"
      ;;
    simstatus)
      local root="."
      if (( $# == 4 )) && [[ "$3" == "--path" ]]; then
        root="$4"
      elif (( $# > 2 )); then
        die "usage: sesh simstatus [--path DIR]"
      fi
      cmd_simstatus "$root"
      ;;
    -h|--help) usage ;;
    *) die "unknown subcommand: $cmd" ;;
  esac
}

main "$@"
